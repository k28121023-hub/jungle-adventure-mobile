<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å–®å­—çµäººå†’éšªéŠæˆ² (Mobile Fixed)</title>
    <!-- å¼•å…¥ React å’Œ Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        
        /* åŸºç¤è¨­å®š */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Sans TC', sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
            /* åœ¨ Body å±¤ç´šç¦æ­¢é è¨­è§¸æ§è¡Œç‚º (å¦‚æ²å‹•)ï¼Œä½†åœ¨æŒ‰éˆ•ä¸Šé–‹å•Ÿ */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #root {
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
        }

        /* é‡è¦ï¼šå…è¨±æŒ‰éˆ•è¢«é»æ“Š */
        button {
            touch-action: manipulation;
            cursor: pointer;
        }

        /* éŠæˆ²å…§çš„è™›æ“¬æŒ‰éµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è¡Œç‚ºä»¥é˜²æ­¢å»¶é² */
        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5rem;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            touch-action: none; /* éŠæˆ²æŒ‰éµä¸éœ€è¦ç€è¦½å™¨æ‰‹å‹¢ */
        }
        
        .touch-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.4);
            border-color: white;
        }

        .shoot-btn {
            background: rgba(239, 68, 68, 0.4);
            border-color: rgba(239, 68, 68, 0.8);
        }
        .shoot-btn:active {
            background: rgba(239, 68, 68, 0.7);
        }

        .jump-btn {
            background: rgba(59, 130, 246, 0.4);
            border-color: rgba(59, 130, 246, 0.8);
        }

        .animate-bounce-text {
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(-5%); }
            50% { transform: translateY(5%); }
        }

        .landscape-warning {
            display: none;
        }
        
        @media (orientation: portrait) {
            .landscape-warning {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- éŠæˆ²è³‡æ–™ ---
        const VOCABULARY = [
            { en: "Handbook", zh: "æ‰‹å†Š" }, { en: "President", zh: "ç¸½çµ±" },
            { en: "Tour", zh: "å·¡è¦–" }, { en: "Name Tag", zh: "å§“åè²¼" },
            { en: "Paperwork", zh: "æ–‡æ›¸" }, { en: "Supervisor", zh: "ç›£ç£è€…" },
            { en: "Agreement", zh: "å”å®š" }, { en: "Package", zh: "æ–‡ä»¶åŒ…" },
            { en: "Training Schedule", zh: "è¨“ç·´æ™‚ç¨‹" }, { en: "Toast", zh: "ä¹¾æ¯" },
            { en: "Tray", zh: "æ‰˜ç›¤" }, { en: "Counter", zh: "æ«ƒå°" },
            { en: "Event", zh: "æ´»å‹•" }, { en: "Client", zh: "é¡§å®¢" },
            { en: "Security", zh: "å®‰å…¨" }, { en: "Coworker", zh: "åŒäº‹" },
            { en: "Go Through", zh: "å¯©é–±" }
        ];

        const ASSETS_CONFIG = {
            hunter: { src: 'hunter.png', emoji: 'ğŸ¤ ' },
            boss:   { src: 'dinosaur.png', emoji: 'ğŸ¦–' }, 
            eagle:    { src: 'eagle.png', emoji: 'ğŸ¦…' },
            tiger:    { src: 'tiger.png', emoji: 'ğŸ¯' },
            elephant: { src: 'elephant.png', emoji: 'ğŸ˜' },
            fox:      { src: 'fox.png', emoji: 'ğŸ¦Š' },
            monkey:   { src: 'monkey.png', emoji: 'ğŸ’' },
            hunter_up:   { src: 'hunter2.png', emoji: 'ğŸ¤ ' },
            hunter_left: { src: 'hunter3.png', emoji: 'ğŸ¤ ' },
            hunter_crouch: { src: 'hunter4.png', emoji: 'ğŸ¤ ' },
            wall: { src: 'wall.png', emoji: 'ğŸ§±' },
            tree: { src: 'tree.png', emoji: 'ğŸŒ²' },
            rock: { src: 'rock.png', emoji: 'ğŸª¨' },
            cactus: { src: 'cactus.png', emoji: 'ğŸŒµ' } 
        };

        const MONSTER_KEYS = ["eagle", "tiger", "elephant", "fox", "monkey"];
        const OBSTACLE_TYPES = [
            { type: "ğŸ“¦", key: "wall", solid: true, damage: false, w: 40, h: 40 },
            { type: "ğŸ§±", key: "wall", solid: true, damage: false, w: 40, h: 90 },
            { type: "ğŸª¨", key: "rock", solid: true, damage: false, w: 50, h: 30 },
            { type: "ğŸŒµ", key: "cactus", solid: false, damage: true, w: 30, h: 40 },
        ];

        // --- Hooks & Helpers ---
        const useGameAssets = () => {
            const [images, setImages] = useState({});
            useEffect(() => {
                const loadedImages = {};
                Object.keys(ASSETS_CONFIG).forEach(key => {
                    const img = new Image();
                    img.src = ASSETS_CONFIG[key].src;
                    loadedImages[key] = img;
                });
                setImages(loadedImages);
            }, []);
            return images;
        };

        const generateSimilarWord = (originalWord) => {
            if (!originalWord || originalWord.length <= 2) return originalWord + "s";
            let chars = originalWord.split('');
            const len = chars.length;
            const method = Math.floor(Math.random() * 4);
            const idx = Math.floor(Math.random() * len);
            if (method === 0 && len > 1) {
                const swapIdx = idx < len - 1 ? idx : idx - 1;
                [chars[swapIdx], chars[swapIdx+1]] = [chars[swapIdx+1], chars[swapIdx]];
            } else if (method === 1) {
                const c = chars[idx].toLowerCase();
                if (c === 'e') chars[idx] = 'a';
                else if (c === 'a') chars[idx] = 'e';
                else chars[idx] = String.fromCharCode(97 + Math.floor(Math.random() * 26));
            } else if (method === 2 && len > 3) {
                chars.splice(idx, 1);
            } else {
                chars.splice(idx, 0, String.fromCharCode(97 + Math.floor(Math.random() * 26)));
            }
            const newWord = chars.join('');
            return newWord === originalWord ? newWord + "s" : newWord;
        };

        const drawEntity = (ctx, assets, type, x, y, w, h, frameCount = 0, isMoving = false, isAimingUp = false, isCrouching = false, facing = 'right') => {
            let currentType = type;
            let flip = false;
            if (type === 'hunter') {
                if (isCrouching) { currentType = 'hunter_crouch'; if (facing === 'left') flip = true; } 
                else if (isAimingUp) { currentType = 'hunter_up'; if (facing === 'left') flip = true; } 
                else if (facing === 'left') { currentType = 'hunter_left'; } 
                else { currentType = 'hunter'; }
            }
            if (type === 'ğŸ“¦' || type === 'ğŸ§±') currentType = 'wall';
            else if (type === 'ğŸª¨') currentType = 'rock';
            else if (type === 'ğŸŒµ') currentType = 'cactus';

            const asset = ASSETS_CONFIG[currentType] || {};
            const img = assets[currentType];
            
            let drawY = y; let rotation = 0;
            if (isMoving && type === 'hunter' && !isAimingUp && !isCrouching) {
                drawY += Math.sin(frameCount * 0.2) * 3;
                rotation = Math.sin(frameCount * 0.15) * 0.05;
            }
            if (type === 'hunter' && isCrouching) drawY += 10;

            ctx.save();
            ctx.translate(x + w/2, drawY + h/2);
            ctx.rotate(rotation);
            if (flip) ctx.scale(-1, 1);
            ctx.translate(-(x + w/2), -(drawY + h/2));

            if (img && img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, x, drawY, w, h);
            } else {
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const fontSize = Math.min(w, h); ctx.font = `${fontSize}px Arial`;
                ctx.fillStyle = '#fff'; ctx.fillText(asset.emoji || type, x + w/2, drawY + h/2);
            }
            ctx.restore();
        };

        const drawRoundRect = (ctx, x, y, w, h, r) => {
            if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
            ctx.beginPath(); ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        };

        // --- æ§åˆ¶å…ƒä»¶ ---
        const Controls = ({ onInput }) => {
            const handleAction = (key, active) => (e) => {
                if(e.cancelable && e.type !== 'mousedown') e.preventDefault(); // é˜²æ­¢è§¸æ§æ™‚ç”¢ç”Ÿé¡å¤–çš„æ»‘é¼ äº‹ä»¶
                e.stopPropagation();
                onInput(key, active);
            };

            return (
                <div className="absolute inset-0 pointer-events-none z-50">
                    <div className="absolute bottom-6 left-6 pointer-events-auto">
                        <div className="flex flex-col items-center gap-2">
                             <div className="flex gap-4">
                                <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                     onTouchStart={handleAction('ArrowLeft', true)} onTouchEnd={handleAction('ArrowLeft', false)}
                                     onMouseDown={handleAction('ArrowLeft', true)} onMouseUp={handleAction('ArrowLeft', false)}>â¬…</div>
                                <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                     onTouchStart={handleAction('ArrowRight', true)} onTouchEnd={handleAction('ArrowRight', false)}
                                     onMouseDown={handleAction('ArrowRight', true)} onMouseUp={handleAction('ArrowRight', false)}>â¡</div>
                             </div>
                             <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                  onTouchStart={handleAction('ArrowDown', true)} onTouchEnd={handleAction('ArrowDown', false)}
                                  onMouseDown={handleAction('ArrowDown', true)} onMouseUp={handleAction('ArrowDown', false)}>â¬‡</div>
                        </div>
                    </div>

                    <div className="absolute bottom-8 right-8 pointer-events-auto flex gap-4 items-end">
                        <div className="touch-btn shoot-btn w-20 h-20 md:w-24 md:h-24 mb-2"
                             onTouchStart={handleAction('Space', true)} onTouchEnd={handleAction('Space', false)}
                             onMouseDown={handleAction('Space', true)} onMouseUp={handleAction('Space', false)}>ğŸ”«</div>
                        <div className="touch-btn jump-btn w-20 h-20 md:w-24 md:h-24 mb-16"
                             onTouchStart={handleAction('ArrowUp', true)} onTouchEnd={handleAction('ArrowUp', false)}
                             onMouseDown={handleAction('ArrowUp', true)} onMouseUp={handleAction('ArrowUp', false)}>â¬†</div>
                    </div>
                </div>
            );
        };

        // --- ä¸»æ‡‰ç”¨ ---
        function App() {
            const [gameState, setGameState] = useState('menu'); 
            const [score, setScore] = useState(0);
            const [hp, setHp] = useState(100);
            const assets = useGameAssets();

            const startGame = () => { console.log("Start Game Clicked"); setScore(0); setHp(100); setGameState('level1'); };
            const handleLevel1Complete = (finalHp) => { setHp(finalHp); setGameState('transition'); };
            const startLevel2 = () => { setHp(100); setGameState('level2'); };
            const handleGameOver = () => { setGameState('gameover'); };
            const handleWin = () => { setGameState('win'); };

            return (
                <div className="w-full h-full relative bg-gray-900 select-none">
                    <div className="landscape-warning fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center text-white p-8 text-center">
                        <div className="text-6xl mb-4">ğŸ“±â¡ï¸ğŸ“±</div>
                        <h2 className="text-2xl font-bold mb-2">è«‹æ—‹è½‰æ‚¨çš„è£ç½®</h2>
                        <p>ç‚ºäº†ç²å¾—æœ€ä½³éŠæˆ²é«”é©—ï¼Œè«‹å°‡æ‰‹æ©Ÿè½‰ç‚ºæ©«å‘ã€‚</p>
                        <button onClick={() => document.querySelector('.landscape-warning').style.display = 'none'} className="mt-4 px-4 py-2 border border-white rounded text-sm opacity-50">å¼·åˆ¶é€²å…¥ (ä¸æ¨è–¦)</button>
                    </div>

                    <div className="game-container">
                        {gameState === 'menu' && <MenuScreen onStart={startGame} />}
                        {gameState === 'level1' && <Level1Engine hp={hp} setHp={setHp} onComplete={handleLevel1Complete} onGameOver={handleGameOver} assets={assets} />}
                        {gameState === 'transition' && <TransitionScreen onNext={startLevel2} hp={hp} />}
                        {gameState === 'level2' && <Level2Engine hp={hp} setHp={setHp} onWin={handleWin} onGameOver={handleGameOver} assets={assets} />}
                        {gameState === 'win' && <WinScreen onRestart={() => setGameState('menu')} />}
                        {gameState === 'gameover' && <GameOverScreen onRestart={() => setGameState('menu')} score={score} />}
                    </div>
                </div>
            );
        }

        // --- ç•«é¢å…ƒä»¶ ---
        const MenuScreen = ({ onStart }) => {
            // è™•ç†è§¸æ§çµæŸäº‹ä»¶ï¼Œç¢ºä¿æŒ‰éˆ•åœ¨æ‰‹æ©Ÿä¸Šéˆæ•
            const handleTouchEnd = (e) => {
                e.preventDefault();
                onStart();
            };
            return (
                <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-800 bg-opacity-95 z-40 w-full h-full">
                    <h1 className="text-4xl md:text-6xl font-bold mb-4 text-yellow-400 text-center tracking-wider" style={{textShadow: '4px 4px 0 #000'}}>å–®å­—çµäººå†’éšª</h1>
                    <div className="text-base md:text-xl mb-6 text-center max-w-lg p-4 bg-black bg-opacity-60 rounded-lg border-2 border-gray-600">
                        <p className="mb-2 text-white">ç²¾è‹±çµäººï¼Œæº–å‚™å¥½äº†å—ï¼Ÿ</p>
                        <ul className="text-left text-sm md:text-base space-y-2 mt-2 text-gray-200">
                            <li>ğŸŒ² <b>ç¬¬ä¸€é—œï¼š</b> <span className="text-yellow-300">â¬† è·³èº</span> <span className="text-yellow-300">â¬‡ è¶´ä¸‹</span> èº²é¿ï¼Œå°„æ“Šæ­£ç¢ºå–®å­—ï¼</li>
                            <li>ğŸ¦– <b>ç¬¬äºŒé—œï¼š</b> è·³ä¸Šå¹³å°èº²é¿æé¾è¡æ’ï¼Œå°„æ“Šæ­£ç¢ºå–®å­—ï¼</li>
                        </ul>
                    </div>
                    {/* åŒæ™‚ç¶å®š onClick å’Œ onTouchEnd ä»¥ç¢ºä¿ç›¸å®¹æ€§ */}
                    <button 
                        onClick={onStart} 
                        onTouchEnd={handleTouchEnd}
                        className="px-10 py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-2xl text-2xl shadow-xl transform transition active:scale-95 border-b-4 border-red-800 touch-manipulation">
                        é–‹å§‹éŠæˆ² (Start)
                    </button>
                </div>
            );
        };

        const TransitionScreen = ({ onNext, hp }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-800 z-40 w-full h-full">
                <h2 className="text-3xl md:text-4xl text-yellow-400 font-bold mb-4">ç¬¬ä¸€é—œå®Œæˆï¼</h2>
                <div className="text-6xl mb-6">ğŸ¤  ğŸ‰</div>
                <p className="text-xl mb-8 text-white">ç›®å‰è¡€é‡: <span className="text-green-400">{hp}%</span> (å³å°‡è£œæ»¿)</p>
                <button onClick={onNext} onTouchEnd={(e) => { e.preventDefault(); onNext(); }} className="px-8 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl text-xl font-bold border-b-4 border-blue-800 text-white">é€²å…¥ç¬¬äºŒé—œ (BOSSæˆ°)</button>
            </div>
        );

        const WinScreen = ({ onRestart }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-yellow-900 z-40 w-full h-full">
                <h2 className="text-5xl text-yellow-300 font-bold mb-4">ä»»å‹™å®Œæˆï¼</h2>
                <p className="text-2xl mb-8 text-center px-4 text-white">ä½ æˆåŠŸæ“Šæ•—äº†æé¾ï¼</p>
                <button onClick={onRestart} onTouchEnd={(e) => { e.preventDefault(); onRestart(); }} className="px-8 py-3 bg-green-600 hover:bg-green-500 rounded-xl text-xl font-bold border-b-4 border-green-800 text-white">å›åˆ°ä¸»é¸å–®</button>
            </div>
        );

        const GameOverScreen = ({ onRestart }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-red-900 z-40 w-full h-full">
                <h2 className="text-5xl text-gray-200 font-bold mb-4">GAME OVER</h2>
                <button onClick={onRestart} onTouchEnd={(e) => { e.preventDefault(); onRestart(); }} className="px-8 py-3 bg-gray-600 hover:bg-gray-500 rounded-xl text-xl font-bold border-b-4 border-gray-800 text-white">é‡æ–°æŒ‘æˆ°</button>
            </div>
        );

        const StatusOverlay = ({ hp, bossHp, currentTarget, feedback, total, completed }) => (
            <div className="absolute top-0 left-0 w-full p-2 flex justify-between items-start pointer-events-none game-overlay z-30">
                <div className="flex flex-col gap-1">
                    <div className="bg-black bg-opacity-60 px-3 py-1 rounded border border-green-500 text-green-400 font-bold text-sm md:text-base">â¤ï¸ {hp}%</div>
                    {total && <div className="bg-black bg-opacity-60 px-3 py-1 rounded border border-blue-500 text-blue-300 font-bold text-sm md:text-base">ğŸ“š {completed} / {total}</div>}
                </div>
                <div className="absolute left-1/2 transform -translate-x-1/2 top-2 w-auto flex flex-col items-center">
                    <div className="bg-red-900 bg-opacity-90 px-4 py-2 rounded-xl border-2 border-red-500 text-center shadow-lg">
                        <div className="text-gray-300 text-[10px] md:text-xs uppercase tracking-widest">ä»»å‹™ç›®æ¨™</div>
                        <div className="text-xl md:text-3xl font-bold text-white whitespace-nowrap"><span className="text-yellow-400">{currentTarget || "..."}</span></div>
                    </div>
                    {feedback && (<div className="mt-2 text-2xl md:text-4xl font-black text-yellow-300 animate-bounce-text" style={{textShadow: '2px 2px 0 red'}}>{feedback}</div>)}
                </div>
                {bossHp !== undefined && (
                    <div className="w-32 md:w-48">
                        <div className="text-right text-red-500 font-bold mb-1 text-xs md:text-sm">BOSS</div>
                        <div className="w-full bg-gray-700 h-4 md:h-6 rounded-full border border-gray-500 overflow-hidden">
                            <div className="bg-red-600 h-full transition-all duration-300" style={{width: `${(bossHp / 140) * 100}%`}}></div>
                        </div>
                    </div>
                )}
            </div>
        );

        // --- LEVEL 1 ENGINE ---
        const Level1Engine = ({ hp, setHp, onComplete, onGameOver, assets }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const [completedCount, setCompletedCount] = useState(0);
            const [totalWords, setTotalWords] = useState(0);
            const [currentTarget, setCurrentTarget] = useState(null);
            const stateRef = useRef({
                hunter: { x: 100, y: 0, width: 40, height: 40, vy: 0, speed: 5, isGrounded: false, hitFlash: 0, facing: 'right' },
                gravity: 0.6, jumpPower: -13, cameraX: 0, shake: 0, 
                bullets: [], particles: [], enemies: [], words: [], obstacles: [], keys: {}, lastShot: 0, frameCount: 0, currentHp: hp, nextSpawnX: 400, isCompleted: false, wordQueue: []
            });

            useEffect(() => {
                const level1Words = VOCABULARY.slice(0, 10);
                const shuffled = [...level1Words].sort(() => 0.5 - Math.random());
                stateRef.current.wordQueue = shuffled;
                setTotalWords(shuffled.length);
                setCurrentTarget(shuffled[0]); // è¨­å®šåˆå§‹ç›®æ¨™
                
                const animate = () => {
                    if (loopRef.current) loopRef.current();
                    requestRef.current = requestAnimationFrame(animate);
                };
                requestRef.current = requestAnimationFrame(animate);
                
                window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
                return () => { 
                    cancelAnimationFrame(requestRef.current); 
                    window.removeEventListener('keydown', handleKeyDown); 
                    window.removeEventListener('keyup', handleKeyUp); 
                };
            }, []);

            useEffect(() => { stateRef.current.currentHp = hp; if(hp <= 0) onGameOver(); }, [hp]);

            const handleWordCompleted = () => {
                const nextQueue = stateRef.current.wordQueue.slice(1);
                stateRef.current.wordQueue = nextQueue;
                const nextWord = nextQueue.length > 0 ? nextQueue[0] : null;
                setCurrentTarget(nextWord);
                setCompletedCount(c => c + 1);
                if (!nextWord) { stateRef.current.isCompleted = true; setTimeout(() => onComplete(stateRef.current.currentHp), 1000); }
            };

            const handleKeyDown = (e) => stateRef.current.keys[e.code] = true;
            const handleKeyUp = (e) => stateRef.current.keys[e.code] = false;
            const handleMobileInput = (key, active) => stateRef.current.keys[key] = active;
            const handleWordCompletedRef = useRef(handleWordCompleted);
            handleWordCompletedRef.current = handleWordCompleted;

            const loopLogic = () => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const state = stateRef.current;
                if (state.isCompleted) return;
                const width = 800; const height = 400; const GROUND_LEVEL = height - 60;
                
                state.frameCount++;
                if (state.hunter.hitFlash > 0) state.hunter.hitFlash--;
                if (state.shake > 0) { state.shake *= 0.9; if(state.shake < 0.5) state.shake = 0; }
                const rectIntersect = (r1, r2) => !(r2.x > r1.x + (r1.w || r1.width) || r2.x + (r2.w || r2.width) < r1.x || r2.y > r1.y + (r1.h || r1.height) || r2.y + (r2.h || r2.height) < r1.y);
                const checkSolidCollision = (rect) => { for (let o of state.obstacles) { if (o.solid && !o.delete && rectIntersect(rect, o)) return o; } return null; };
                const spawnBlood = (x, y) => { for(let i=0; i<8; i++) { state.particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 2, life: 1.0, color: `rgba(255, ${Math.random()*50}, 0, 1)` }); } };

                state.hunter.vy += state.gravity;
                const isCrouching = state.keys['ArrowDown'] && state.hunter.isGrounded;
                let isMoving = false;
                let dx = 0;
                if (!isCrouching) {
                    if (state.keys['ArrowLeft']) { dx -= state.hunter.speed; isMoving = true; state.hunter.facing = 'left'; }
                    if (state.keys['ArrowRight']) { dx += state.hunter.speed; isMoving = true; state.hunter.facing = 'right'; }
                }
                let proposedX = state.hunter.x; let proposedCameraX = state.cameraX;
                if (dx < 0) { if (proposedX > 0) proposedX += dx; } else if (dx > 0) { if (proposedX < width / 2) proposedX += dx; else proposedCameraX += dx; }
                const hunterRectX = { x: proposedX + proposedCameraX, y: state.hunter.y, w: state.hunter.width, h: state.hunter.height };
                let collisionRect = { ...hunterRectX };
                if (isCrouching) { collisionRect.h = 25; collisionRect.y += 15; }

                if (!checkSolidCollision(collisionRect)) { state.hunter.x = proposedX; state.cameraX = proposedCameraX; }

                let nextY = state.hunter.y + state.hunter.vy;
                if (nextY + state.hunter.height >= GROUND_LEVEL) { nextY = GROUND_LEVEL - state.hunter.height; state.hunter.vy = 0; state.hunter.isGrounded = true; } else { state.hunter.isGrounded = false; }
                const hunterRectY = { x: state.hunter.x + state.cameraX, y: nextY, w: state.hunter.width, h: state.hunter.height };
                let collisionRectY = { ...hunterRectY };
                if (isCrouching) { collisionRectY.h = 25; collisionRectY.y += 15; }

                const hitY = checkSolidCollision(collisionRectY);
                if (hitY) { if (state.hunter.vy > 0) { nextY = hitY.y - state.hunter.height; state.hunter.isGrounded = true; state.hunter.vy = 0; } else if (state.hunter.vy < 0) { nextY = hitY.y + hitY.h; state.hunter.vy = 0; } }
                state.hunter.y = nextY;

                if (state.keys['ArrowUp'] && state.hunter.isGrounded && !isCrouching) { state.hunter.vy = state.jumpPower; state.hunter.isGrounded = false; }
                if (state.keys['Space'] && Date.now() - state.lastShot > 300) {
                    const shootUp = state.keys['ArrowUp']; const isLeft = state.hunter.facing === 'left';
                    const bulletVx = shootUp ? 0 : (isLeft ? -10 : 10); const bulletVy = shootUp ? -10 : 0;
                    let spawnY = state.hunter.y + (shootUp ? -10 : 20); if (isCrouching) spawnY += 15;
                    const startX = state.hunter.x + state.cameraX + (shootUp ? 15 : (isLeft ? 0 : 30));
                    state.bullets.push({ x: startX, y: spawnY, w: shootUp ? 5 : 10, h: shootUp ? 10 : 5, vx: bulletVx, vy: bulletVy, delete: false });
                    state.lastShot = Date.now();
                }

                if (state.cameraX + width > state.nextSpawnX) {
                    state.nextSpawnX += 300 + Math.random() * 200;
                    const rand = Math.random();
                    if (rand < 0.4) {
                        const type = MONSTER_KEYS[Math.floor(Math.random() * MONSTER_KEYS.length)];
                        const isFlying = type === 'eagle'; const isMonkey = type === 'monkey';
                        let spawnY = GROUND_LEVEL - 40; if (isFlying) spawnY = Math.random() * (height - 200) + 50; if (isMonkey) spawnY = -50;
                        state.enemies.push({ x: state.cameraX + width + 50, y: spawnY, w: 40, h: 40, type: type, speed: isFlying ? 3 : 2 + Math.random(), hitPlayer: false, delete: false, isFlying: isFlying, isMonkey: isMonkey });
                    } else if (rand < 0.7) {
                        const obstacleType = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
                        state.obstacles.push({ x: state.cameraX + width + 50, y: GROUND_LEVEL - obstacleType.h + 5, w: obstacleType.w, h: obstacleType.h, type: obstacleType.type, key: obstacleType.key, solid: obstacleType.solid, damage: obstacleType.damage, hitPlayer: false, delete: false });
                    } else {
                        const spawnBaseX = state.cameraX + width + 50;
                        if (currentTarget) state.words.push({ x: spawnBaseX, y: 100 + Math.random() * 200, w: 80, h: 30, text: currentTarget.en, isTarget: true, delete: false });
                        if (currentTarget) state.words.push({ x: spawnBaseX + 150, y: 50 + Math.random() * 300, w: 80, h: 30, text: generateSimilarWord(currentTarget.en), isTarget: false, delete: false });
                        let randomWord = VOCABULARY[Math.floor(Math.random() * 10)];
                        if (currentTarget && randomWord.en === currentTarget.en) randomWord = VOCABULARY[(VOCABULARY.indexOf(randomWord) + 1) % 10];
                        state.words.push({ x: spawnBaseX + 80, y: 150 + Math.random() * 200, w: 80, h: 30, text: randomWord.en, isTarget: false, delete: false });
                    }
                }

                state.bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
                state.enemies.forEach(e => { e.x -= e.speed; if (e.isFlying) { const playerCenterY = state.hunter.y + 20; if (e.y < playerCenterY - 10) e.y += 1; else if (e.y > playerCenterY + 10) e.y -= 1; } if (e.isMonkey) { if (e.y < GROUND_LEVEL - 40) e.y += 4; else e.y = GROUND_LEVEL - 40; } });
                state.words.forEach(w => w.x -= 0.5);
                state.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; }); state.particles = state.particles.filter(p => p.life > 0);
                state.bullets = state.bullets.filter(b => b.x < state.cameraX + width && b.y > -50 && !b.delete); state.enemies = state.enemies.filter(e => e.x > state.cameraX - 100 && !e.delete); state.obstacles = state.obstacles.filter(o => o.x > state.cameraX - 100 && !o.delete); state.words = state.words.filter(w => w.x > state.cameraX - 100 && !w.delete);
                
                const hunterWorldBox = { ...state.hunter, x: state.hunter.x + state.cameraX };
                if (isCrouching) { hunterWorldBox.h = 25; hunterWorldBox.y += 15; }

                let wordMatched = false;
                state.bullets.forEach(b => {
                    if (b.delete) return;
                    let hitSomething = false;
                    state.words.forEach(w => {
                        if (hitSomething) return;
                        if (rectIntersect(b, w)) {
                            hitSomething = true; b.delete = true; w.delete = true; 
                            if (w.isTarget) { wordMatched = true; } 
                            else { state.currentHp -= 10; setHp(state.currentHp); state.hunter.hitFlash = 30; spawnBlood(state.hunter.x + 20, state.hunter.y + 20); }
                        }
                    });
                    state.enemies.forEach(e => { if (!e.delete && rectIntersect(b, e)) { b.delete = true; e.delete = true; } });
                });
                state.enemies.forEach(e => { if (!e.delete && !e.hitPlayer && rectIntersect(hunterWorldBox, e)) { e.hitPlayer = true; state.currentHp -= 15; setHp(state.currentHp); state.hunter.hitFlash = 30; state.shake = 15; spawnBlood(state.hunter.x + 20, state.hunter.y + 20); } });
                state.obstacles.forEach(o => { if (!o.delete && !o.hitPlayer && o.damage && rectIntersect(hunterWorldBox, o)) { o.hitPlayer = true; state.currentHp -= 10; setHp(state.currentHp); state.hunter.vy = -5; state.hunter.hitFlash = 30; state.shake = 10; spawnBlood(state.hunter.x + 20, state.hunter.y + 20); } });
                if (wordMatched) handleWordCompletedRef.current();

                let shakeX = 0, shakeY = 0; if (state.shake > 0) { shakeX = (Math.random() - 0.5) * state.shake; shakeY = (Math.random() - 0.5) * state.shake; }
                ctx.save(); ctx.translate(shakeX, shakeY);
                const gradient = ctx.createLinearGradient(0, 0, 0, height); gradient.addColorStop(0, '#3E4E50'); gradient.addColorStop(1, '#1A2525'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
                // Draw clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                const cloudSpeed = 0.1; const scroll = state.cameraX * cloudSpeed;
                const cloudPositions = [{x:100,y:50,s:60}, {x:300,y:80,s:50}, {x:600,y:40,s:70}, {x:900,y:70,s:55}, {x:1200,y:50,s:65}];
                const loopWidth = 1200; const offset = Math.floor(scroll / loopWidth) * loopWidth;
                for (let i = 0; i < 2; i++) {
                    const layerOffset = offset + i * loopWidth;
                    cloudPositions.forEach(cloud => {
                        const drawX = cloud.x + layerOffset - scroll;
                        if (drawX + cloud.s > 0 && drawX - cloud.s < width) {
                            ctx.beginPath(); ctx.arc(drawX, cloud.y, cloud.s * 0.6, 0, Math.PI * 2); ctx.arc(drawX + cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.arc(drawX - cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.fill();
                        }
                    });
                }

                ctx.fillStyle = '#1b2124'; for(let i=0; i<8; i++) { const treeX = i * 150 + 20; ctx.beginPath(); ctx.moveTo(treeX - state.cameraX * 0.3, height); ctx.lineTo(treeX + 30 - state.cameraX * 0.3, height - 200); ctx.lineTo(treeX + 60 - state.cameraX * 0.3, height); ctx.fill(); }
                ctx.fillStyle = '#1a0505'; ctx.fillRect(0, GROUND_LEVEL, width, height - GROUND_LEVEL);
                ctx.fillStyle = '#2e3b2e'; ctx.fillRect(0, GROUND_LEVEL, width, 15);
                state.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha = 1.0;
                if (state.hunter.hitFlash > 0 && Math.floor(state.hunter.hitFlash / 3) % 2 === 0) { ctx.globalAlpha = 0.6; ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(state.hunter.x + 20, state.hunter.y + 20, 25, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha = 1.0;
                const isAimingUp = state.keys['ArrowUp'];
                drawEntity(ctx, assets, 'hunter', state.hunter.x - 5, state.hunter.y, 50, 50, state.frameCount, isMoving, isAimingUp, isCrouching, state.hunter.facing);
                state.obstacles.forEach(o => { const screenX = o.x - state.cameraX; drawEntity(ctx, assets, o.key || o.type, screenX, o.y, o.w, o.h); });
                state.enemies.forEach(e => { const screenX = e.x - state.cameraX; drawEntity(ctx, assets, e.type, screenX, e.y, e.w, e.h, state.frameCount, true); });
                
                ctx.font = '900 16px "Noto Sans TC"'; 
                state.words.forEach(w => { 
                    const screenX = w.x - state.cameraX; 
                    const textMetrics = ctx.measureText(w.text);
                    w.w = textMetrics.width + 30; 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeStyle = '#444'; ctx.lineWidth = 2; 
                    ctx.beginPath(); drawRoundRect(ctx, screenX, w.y, w.w, w.h, 10); ctx.fill(); ctx.stroke(); 
                    ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                    ctx.fillText(w.text, screenX + w.w / 2, w.y + w.h / 2); 
                });
                ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                // Bullet effect inline to save space
                state.bullets.forEach(b => {
                    const screenX = b.x - state.cameraX; const screenY = b.y;
                    ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = '#ff4500'; ctx.fillStyle = '#ff4500'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 7, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                });
                ctx.restore();
            };

            const loopRef = useRef(loopLogic);
            loopRef.current = loopLogic;

            return (
                <div className="w-full h-full relative">
                    <canvas ref={canvasRef} width={800} height={400}/>
                    <StatusOverlay hp={hp} currentTarget={currentTarget?.zh} total={totalWords} completed={completedCount} />
                    <Controls onInput={handleMobileInput} />
                </div>
            );
        };

        // --- LEVEL 2 ENGINE ---
        const Level2Engine = ({ hp, setHp, onWin, onGameOver, assets }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const [bossHp, setBossHp] = useState(140);
            const [currentQ, setCurrentQ] = useState(null);
            const [feedback, setFeedback] = useState("");
            const [qIndex, setQIndex] = useState(0);

            const LEVEL2_WORDS = useRef(VOCABULARY.slice(10, 17)).current;
            const stateRef = useRef({
                hunter: { x: 50, y: 0, width: 40, height: 40, vy: 0, speed: 5, isGrounded: false, hitFlash: 0, facing: 'right' },
                gravity: 0.6, jumpPower: -13,
                boss: { x: 600, y: 200, w: 200, h: 200, vx: 0, vy: 2, state: 'idle', timer: 0, attackTimer: 0, hitFlash: 0 },
                platforms: [{ x: 100, y: 300, w: 100, h: 20 }, { x: 300, y: 220, w: 100, h: 20 }, { x: 500, y: 150, w: 100, h: 20 }, { x: 200, y: 100, w: 80, h: 20 }],
                bullets: [], particles: [], words: [], bossAttacks: [], obstacles: [], enemies: [], keys: {}, lastShot: 0, wordTimer: 0, frameCount: 0, currentHp: hp, bossHp: 140, shake: 0, cameraX: 0
            });

            useEffect(() => {
                setCurrentQ(LEVEL2_WORDS[0]);
                const animate = () => {
                    if (loopRef.current) loopRef.current();
                    requestRef.current = requestAnimationFrame(animate);
                };
                requestRef.current = requestAnimationFrame(animate);

                window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
                return () => { 
                    cancelAnimationFrame(requestRef.current);
                    window.removeEventListener('keydown', handleKeyDown); 
                    window.removeEventListener('keyup', handleKeyUp); 
                };
            }, []);

            useEffect(() => { stateRef.current.currentHp = hp; if(hp <= 0) onGameOver(); }, [hp]);

            const spawnWords = (targetWord) => {
                const words = [];
                const correct = targetWord || stateRef.current.currentQ || VOCABULARY[0];
                const getRandomPos = () => ({ x: 200 + Math.random() * 500, y: 50 + Math.random() * 250 });
                let pos = getRandomPos();
                words.push({ text: correct.en, x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: true, w: 80, h: 30, life: 180 });
                pos = getRandomPos();
                words.push({ text: generateSimilarWord(correct.en), x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: false, w: 80, h: 30, life: 180 });
                pos = getRandomPos();
                let distractor = LEVEL2_WORDS[Math.floor(Math.random() * LEVEL2_WORDS.length)];
                while(distractor.en === correct.en) { distractor = LEVEL2_WORDS[Math.floor(Math.random() * LEVEL2_WORDS.length)]; }
                words.push({ text: distractor.en, x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: false, w: 80, h: 30, life: 180 });
                stateRef.current.words = words;
            };

            const nextQuestion = () => {
                const nextIdx = qIndex + 1;
                if (nextIdx >= LEVEL2_WORDS.length) { onWin(); } else { setQIndex(nextIdx); setCurrentQ(LEVEL2_WORDS[nextIdx]); stateRef.current.words = []; stateRef.current.wordTimer = 180; }
            };

            const handleKeyDown = (e) => stateRef.current.keys[e.code] = true;
            const handleKeyUp = (e) => stateRef.current.keys[e.code] = false;
            const handleMobileInput = (key, active) => stateRef.current.keys[key] = active;

            const spawnBlood = (x, y) => { for(let i=0; i<8; i++) { stateRef.current.particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 2, life: 1.0, color: `rgba(255, ${Math.random()*50}, 0, 1)` }); } };
            const rectIntersect = (r1, r2) => !(r2.x > r1.x + (r1.w || r1.width) || r2.x + (r2.w || r2.width) < r1.x || r2.y > r1.y + (r1.h || r1.height) || r2.y + (r2.h || r2.height) < r1.y);

            const loopLogic = () => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const state = stateRef.current;
                const width = 800; const height = 400; const GROUND_LEVEL = height - 60;

                state.frameCount++;
                if (state.hunter.hitFlash > 0) state.hunter.hitFlash--;
                if (state.boss.hitFlash > 0) state.boss.hitFlash--; 
                if (state.shake > 0) { state.shake *= 0.9; if(state.shake < 0.5) state.shake = 0; }

                state.hunter.vy += state.gravity;
                const isCrouching = state.keys['ArrowDown'] && state.hunter.isGrounded;
                let isMoving = false;
                if (!isCrouching) {
                    if (state.keys['ArrowLeft']) { state.hunter.x -= state.hunter.speed; isMoving = true; state.hunter.facing = 'left'; }
                    if (state.keys['ArrowRight']) { state.hunter.x += state.hunter.speed; isMoving = true; state.hunter.facing = 'right'; }
                }
                if (state.hunter.x < 0) state.hunter.x = 0;
                if (state.hunter.x > width - state.hunter.width) state.hunter.x = width - state.hunter.width;

                let nextY = state.hunter.y + state.hunter.vy;
                let grounded = false;
                if (nextY + state.hunter.height >= GROUND_LEVEL) { nextY = GROUND_LEVEL - state.hunter.height; state.hunter.vy = 0; grounded = true; }
                const playerBottom = state.hunter.y + state.hunter.height;
                state.platforms.forEach(p => { if (state.hunter.vy > 0 && state.hunter.x + state.hunter.width > p.x && state.hunter.x < p.x + p.w && playerBottom <= p.y + 10 && nextY + state.hunter.height >= p.y) { nextY = p.y - state.hunter.height; state.hunter.vy = 0; grounded = true; } });
                state.hunter.y = nextY;
                state.hunter.isGrounded = grounded;

                if (state.keys['ArrowUp'] && state.hunter.isGrounded && !isCrouching) { state.hunter.vy = state.jumpPower; state.hunter.isGrounded = false; }

                if (state.keys['Space'] && Date.now() - state.lastShot > 300) {
                    const shootUp = state.keys['ArrowUp']; const isLeft = state.hunter.facing === 'left';
                    const bulletVx = shootUp ? 0 : (isLeft ? -12 : 12); const bulletVy = shootUp ? -12 : 0;
                    let spawnY = state.hunter.y + (shootUp ? -10 : 20); if (isCrouching) spawnY += 15;
                    const startX = state.hunter.x + state.cameraX + (shootUp ? 15 : (isLeft ? 0 : 30));
                    state.bullets.push({ x: startX, y: spawnY, w: shootUp ? 5 : 10, h: shootUp ? 10 : 5, vx: bulletVx, vy: bulletVy, delete: false });
                    state.lastShot = Date.now();
                }

                if (state.boss.state === 'idle') {
                    state.boss.y = 200 + Math.sin(state.frameCount * 0.05) * 50;
                    state.boss.timer++;
                    if (state.boss.timer > 180) { state.boss.state = Math.random() > 0.5 ? 'advance' : 'fire'; state.boss.timer = 0; }
                } else if (state.boss.state === 'advance') {
                    state.boss.x -= 5;
                    if (state.boss.x < 100) { state.boss.state = 'retreat'; }
                } else if (state.boss.state === 'retreat') {
                    state.boss.x += 3;
                    if (state.boss.x >= 600) { state.boss.state = 'idle'; }
                } else if (state.boss.state === 'fire') {
                    if (state.boss.timer === 0 || state.boss.timer === 20 || state.boss.timer === 40) {
                        const angle = Math.atan2(state.hunter.y - (state.boss.y + 40), state.hunter.x - state.boss.x);
                        state.bossAttacks.push({ x: state.boss.x, y: state.boss.y + 40, vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15, w: 30, h: 10, type: 'blue_beam', angle: angle });
                    }
                    state.boss.timer++;
                    if (state.boss.timer > 60) { state.boss.state = 'idle'; state.boss.timer = 0; }
                }

                state.wordTimer++;
                if (state.wordTimer > 200 && state.words.length === 0 && LEVEL2_WORDS[qIndex]) { spawnWords(LEVEL2_WORDS[qIndex]); state.wordTimer = 0; }

                state.words.forEach(w => { w.x += w.vx; w.y += w.vy; w.life--; if(w.x < 50 || w.x > width - 100) w.vx *= -1; if(w.y < 50 || w.y > height - 100) w.vy *= -1; if (w.life <= 0) w.delete = true; });
                state.words = state.words.filter(w => !w.delete);

                state.bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
                state.bossAttacks.forEach(a => { a.x += a.vx; a.y += a.vy; });
                if(state.particles) { state.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; }); state.particles = state.particles.filter(p => p.life > 0); }

                state.bullets = state.bullets.filter(b => b.x < width && b.y > -50 && !b.delete);
                state.bossAttacks = state.bossAttacks.filter(a => a.x > -50 && !a.delete);

                const hunterBox = { x: state.hunter.x, y: state.hunter.y, w: state.hunter.width, h: state.hunter.height };
                if (isCrouching) { hunterBox.h = 25; hunterBox.y += 15; }
                const bossBox = { x: state.boss.x, y: state.boss.y, w: state.boss.w, h: state.boss.h };

                state.bullets.forEach((b) => {
                    if(b.delete) return;
                    let hitSomething = false;
                    state.words.forEach(w => {
                        if (hitSomething) return;
                        if (rectIntersect(b, w)) {
                            hitSomething = true; b.delete = true; w.delete = true; 
                            if (w.isCorrect) {
                                state.bossHp -= 20; setBossHp(state.bossHp); state.shake = 10; setFeedback("HIT! ğŸ’¥"); state.boss.hitFlash = 30; 
                                setTimeout(() => { setFeedback(""); nextQuestion(); }, 500);
                            } else { 
                                setFeedback("WRONG! ğŸ’¢"); setTimeout(() => setFeedback(""), 500); state.words = []; state.wordTimer = 150; 
                            }
                        }
                    });
                    if (!hitSomething && rectIntersect(b, bossBox)) { b.delete = true; state.particles.push({ x: b.x, y: b.y, vx: -5, vy: (Math.random()-0.5)*10, life: 0.5, color: '#ffff00' }); }
                });

                if (state.hunter.hitFlash <= 0) {
                    if (rectIntersect(hunterBox, bossBox)) { state.currentHp -= 20; setHp(state.currentHp); state.hunter.hitFlash = 40; state.shake = 20; state.hunter.vy = -10; state.hunter.x -= 50; spawnBlood(state.hunter.x, state.hunter.y); }
                    state.bossAttacks.forEach(a => { if (!a.delete && rectIntersect(hunterBox, a)) { a.delete = true; state.currentHp -= 15; setHp(state.currentHp); state.hunter.hitFlash = 30; state.shake = 10; spawnBlood(state.hunter.x, state.hunter.y); } });
                }

                let shakeX = 0, shakeY = 0; if (state.shake > 0) { shakeX = (Math.random() - 0.5) * state.shake; shakeY = (Math.random() - 0.5) * state.shake; }
                ctx.save(); ctx.translate(shakeX, shakeY);
                const gradient = ctx.createLinearGradient(0, 0, 0, height); gradient.addColorStop(0, '#3E4E50'); gradient.addColorStop(1, '#1A2525'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
                // Clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                const cloudSpeed = 0.1; const scroll = 0; // Boss level static bg
                const cloudPositions = [{x:100,y:50,s:60}, {x:300,y:80,s:50}, {x:600,y:40,s:70}, {x:900,y:70,s:55}, {x:1200,y:50,s:65}];
                cloudPositions.forEach(cloud => {
                    const drawX = cloud.x;
                    ctx.beginPath(); ctx.arc(drawX, cloud.y, cloud.s * 0.6, 0, Math.PI * 2); ctx.arc(drawX + cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.arc(drawX - cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.fill();
                });

                ctx.fillStyle = '#1b2124'; for(let i=0; i<8; i++) { const treeX = i * 120 + 20; ctx.beginPath(); ctx.moveTo(treeX, height); ctx.lineTo(treeX + 30, height - 200 - Math.random()*50); ctx.lineTo(treeX + 60, height); ctx.fill(); }
                ctx.fillStyle = '#1a0505'; ctx.fillRect(0, GROUND_LEVEL, width, height - GROUND_LEVEL);
                ctx.fillStyle = '#2e3b2e'; ctx.fillRect(0, GROUND_LEVEL, width, 15);
                
                ctx.fillStyle = '#5d4037';
                state.platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = '#3e2723'; ctx.strokeRect(p.x, p.y, p.w, p.h); });

                state.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha = 1.0;
                if (state.hunter.hitFlash > 0 && Math.floor(state.hunter.hitFlash / 3) % 2 === 0) { ctx.globalAlpha = 0.6; ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(state.hunter.x + 20, state.hunter.y + 20, 25, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha = 1.0;
                const isAimingUp = state.keys['ArrowUp'];
                drawEntity(ctx, assets, 'hunter', state.hunter.x - 5, state.hunter.y, 50, 50, state.frameCount, isMoving, isAimingUp, isCrouching, state.hunter.facing);
                drawEntity(ctx, assets, 'boss', state.boss.x, state.boss.y, state.boss.w, state.boss.h, state.frameCount, true); 
                
                if (state.boss.hitFlash > 0) { ctx.strokeStyle = `rgba(255, 0, 0, ${state.boss.hitFlash / 30})`; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(state.boss.x + state.boss.w/2, state.boss.y + state.boss.h/2, 80, 0, Math.PI*2); ctx.stroke(); }

                state.bossAttacks.forEach(a => {
                    if (a.type === 'blue_beam') {
                        ctx.save(); ctx.translate(a.x, a.y); ctx.rotate(a.angle || 0); 
                        ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#00ffff'; ctx.fillRect(0, -5, a.w, a.h); 
                        ctx.fillStyle = '#ffffff'; ctx.fillRect(0, -2, a.w, a.h/2); ctx.restore();
                    } else { ctx.font = '30px Arial'; ctx.fillText('ğŸ”¥', a.x, a.y + 20); }
                });
                
                ctx.font = '900 16px "Noto Sans TC"'; 
                state.words.forEach(w => { 
                    const textMetrics = ctx.measureText(w.text); w.w = textMetrics.width + 30;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeStyle = '#444'; ctx.lineWidth = 2; 
                    ctx.beginPath(); drawRoundRect(ctx, w.x, w.y, w.w, w.h, 10); ctx.fill(); ctx.stroke(); 
                    ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                    ctx.fillText(w.text, w.x + w.w / 2, w.y + w.h / 2); 
                });
                ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                // Inline bullet effect
                state.bullets.forEach(b => {
                    const screenX = b.x; const screenY = b.y;
                    ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = '#ff4500'; ctx.fillStyle = '#ff4500'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 7, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                });
                ctx.restore();
            };

            const loopRef = useRef(loopLogic);
            loopRef.current = loopLogic;

            return (
                <div className="w-full h-full relative">
                    <canvas ref={canvasRef} width={800} height={400}/>
                    <StatusOverlay hp={hp} bossHp={bossHp} currentTarget={currentQ?.zh} feedback={feedback} />
                    <Controls onInput={handleMobileInput} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>