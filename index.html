<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÂñÆÂ≠óÁçµ‰∫∫ÂÜíÈö™ÈÅäÊà≤ (Stable V2)</title>
    
    <!-- ‰ΩøÁî® cdnjsÔºå‰∏¶Âä†ÂÖ•ÈåØË™§ËôïÁêÜ -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Sans TC', sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #root { width: 100%; height: 100%; }

        canvas {
            display: block;
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            background-color: #1a1a1a;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
        }

        button { touch-action: manipulation; cursor: pointer; }

        /* ÊåâÈàïÊ®£Âºè */
        .touch-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(2px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5rem;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            touch-action: none; 
        }
        .touch-btn:active { transform: scale(0.9); background: rgba(255, 255, 255, 0.4); border-color: white; }
        .shoot-btn { background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.6); }
        .shoot-btn:active { background: rgba(239, 68, 68, 0.6); }
        .jump-btn { background: rgba(59, 130, 246, 0.3); border-color: rgba(59, 130, 246, 0.6); }

        .animate-bounce-text { animation: bounce 1s infinite; }
        @keyframes bounce { 0%, 100% { transform: translateY(-5%); } 50% { transform: translateY(5%); } }

        .landscape-warning { display: none; }
        @media (orientation: portrait) { .landscape-warning { display: flex; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, Component } = React;

        // --- ÂÖ®Â±ÄÈåØË™§ÈÇäÁïå (Error Boundary) ---
        class ErrorBoundary extends Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            componentDidCatch(error, errorInfo) { console.error("Game Error:", error, errorInfo); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-900 text-white p-4">
                            <h2 className="text-3xl text-red-500 mb-4">‚ö†Ô∏è ÈÅäÊà≤ÁôºÁîüÈåØË™§</h2>
                            <pre className="bg-black p-4 rounded text-xs text-gray-300 mb-4 max-w-full overflow-auto">
                                {this.state.error?.toString()}
                            </pre>
                            <button onClick={() => window.location.reload()} className="px-6 py-3 bg-blue-600 rounded-lg">ÈáçÊñ∞ËºâÂÖ• (Reload)</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- ÈÅäÊà≤Ë≥áÊñô ---
        const VOCABULARY = [
            { en: "Handbook", zh: "ÊâãÂÜä" }, { en: "President", zh: "Á∏ΩÁµ±" },
            { en: "Tour", zh: "Â∑°Ë¶ñ" }, { en: "Name Tag", zh: "ÂßìÂêçË≤º" },
            { en: "Paperwork", zh: "ÊñáÊõ∏" }, { en: "Supervisor", zh: "Áõ£Áù£ËÄÖ" },
            { en: "Agreement", zh: "ÂçîÂÆö" }, { en: "Package", zh: "Êñá‰ª∂ÂåÖ" },
            { en: "Training Schedule", zh: "Ë®ìÁ∑¥ÊôÇÁ®ã" }, { en: "Toast", zh: "‰πæÊùØ" },
            { en: "Tray", zh: "ÊâòÁõ§" }, { en: "Counter", zh: "Ê´ÉÂè∞" },
            { en: "Event", zh: "Ê¥ªÂãï" }, { en: "Client", zh: "È°ßÂÆ¢" },
            { en: "Security", zh: "ÂÆâÂÖ®" }, { en: "Coworker", zh: "Âêå‰∫ã" },
            { en: "Go Through", zh: "ÂØ©Èñ±" }
        ];

        const ASSETS_CONFIG = {
            hunter: { src: 'hunter.png', emoji: 'ü§†' },
            boss:   { src: 'dinosaur.png', emoji: 'ü¶ñ' }, 
            eagle:    { src: 'eagle.png', emoji: 'ü¶Ö' },
            tiger:    { src: 'tiger.png', emoji: 'üêØ' },
            elephant: { src: 'elephant.png', emoji: 'üêò' },
            fox:      { src: 'fox.png', emoji: 'ü¶ä' },
            monkey:   { src: 'monkey.png', emoji: 'üêí' },
            hunter_up:   { src: 'hunter2.png', emoji: 'ü§†' },
            hunter_left: { src: 'hunter3.png', emoji: 'ü§†' },
            hunter_crouch: { src: 'hunter4.png', emoji: 'ü§†' },
            wall: { src: 'wall.png', emoji: 'üß±' },
            tree: { src: 'tree.png', emoji: 'üå≤' },
            rock: { src: 'rock.png', emoji: 'ü™®' },
            cactus: { src: 'cactus.png', emoji: 'üåµ' } 
        };

        const MONSTER_KEYS = ["eagle", "tiger", "elephant", "fox", "monkey"];
        // ÊîæÂ§ßÁâ©‰ª∂Â∞∫ÂØ∏ (Scale x1.3)
        const OBSTACLE_TYPES = [
            { type: "üì¶", key: "wall", solid: true, damage: false, w: 80, h: 80 },
            { type: "üß±", key: "wall", solid: true, damage: false, w: 80, h: 160 },
            { type: "ü™®", key: "rock", solid: true, damage: false, w: 90, h: 60 },
            { type: "üåµ", key: "cactus", solid: false, damage: true, w: 60, h: 80 },
        ];

        // --- Hooks & Helpers ---
        const useGameAssets = () => {
            const [images, setImages] = useState({});
            const [loaded, setLoaded] = useState(false);
            
            useEffect(() => {
                const loadedImages = {};
                let count = 0;
                const total = Object.keys(ASSETS_CONFIG).length;
                
                Object.keys(ASSETS_CONFIG).forEach(key => {
                    const img = new Image();
                    img.src = ASSETS_CONFIG[key].src;
                    img.onload = () => {
                        count++;
                        if (count === total) setLoaded(true);
                    };
                    img.onerror = () => {
                        // Âç≥‰ΩøËºâÂÖ•Â§±Êïó‰πüË¶ñÁÇ∫ÂÆåÊàêÔºåÊúÉ‰ΩøÁî® Fallback Emoji
                        console.warn(`Failed to load: ${key}`);
                        count++;
                        if (count === total) setLoaded(true);
                    };
                    loadedImages[key] = img;
                });
                setImages(loadedImages);
                // Fallback: Â¶ÇÊûú 2ÁßíÂæåÈÇÑÊ≤íËºâÂÖ•ÂÆåÔºåÁõ¥Êé•ÈñãÂßã
                setTimeout(() => setLoaded(true), 2000);
            }, []);
            return { images, loaded };
        };

        const generateSimilarWord = (originalWord) => {
            if (!originalWord || originalWord.length <= 2) return (originalWord || "") + "s";
            try {
                let chars = originalWord.split('');
                const len = chars.length;
                const method = Math.floor(Math.random() * 4);
                const idx = Math.floor(Math.random() * len);
                if (method === 0 && len > 1) {
                    const swapIdx = idx < len - 1 ? idx : idx - 1;
                    [chars[swapIdx], chars[swapIdx+1]] = [chars[swapIdx+1], chars[swapIdx]];
                } else if (method === 1) {
                    const c = chars[idx].toLowerCase();
                    if (c === 'e') chars[idx] = 'a';
                    else if (c === 'a') chars[idx] = 'e';
                    else chars[idx] = String.fromCharCode(97 + Math.floor(Math.random() * 26));
                } else if (method === 2 && len > 3) {
                    chars.splice(idx, 1);
                } else {
                    chars.splice(idx, 0, String.fromCharCode(97 + Math.floor(Math.random() * 26)));
                }
                const newWord = chars.join('');
                return newWord === originalWord ? newWord + "s" : newWord;
            } catch (e) { return originalWord + "s"; }
        };

        const drawEntity = (ctx, assets, type, x, y, w, h, frameCount = 0, isMoving = false, isAimingUp = false, isCrouching = false, facing = 'right') => {
            if (!ctx) return;
            let currentType = type;
            let flip = false;
            
            if (type === 'hunter') {
                if (isCrouching) { currentType = 'hunter_crouch'; if (facing === 'left') flip = true; } 
                else if (isAimingUp) { currentType = 'hunter_up'; if (facing === 'left') flip = true; } 
                else if (facing === 'left') { currentType = 'hunter_left'; } 
                else { currentType = 'hunter'; }
            }
            if (type === 'üì¶' || type === 'üß±') currentType = 'wall';
            else if (type === 'ü™®') currentType = 'rock';
            else if (type === 'üåµ') currentType = 'cactus';

            const asset = ASSETS_CONFIG[currentType] || { emoji: '‚ùì' };
            const img = assets[currentType];
            
            let drawY = y; let rotation = 0;
            if (isMoving && type === 'hunter' && !isAimingUp && !isCrouching) {
                drawY += Math.sin(frameCount * 0.2) * 3;
                rotation = Math.sin(frameCount * 0.15) * 0.05;
            }
            if (type === 'hunter' && isCrouching) drawY += 10;

            ctx.save();
            ctx.translate(x + w/2, drawY + h/2);
            ctx.rotate(rotation);
            if (flip) ctx.scale(-1, 1);
            ctx.translate(-(x + w/2), -(drawY + h/2));

            // ÂÆâÂÖ®Áπ™ÂúñÔºöÁ¢∫‰øùÂúñÁâáÁâ©‰ª∂Â≠òÂú®‰∏îÂ∑≤ËºâÂÖ•
            if (img && img.complete && img.naturalWidth > 0) {
                try {
                    ctx.drawImage(img, x, drawY, w, h);
                } catch (e) {
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const fontSize = Math.min(w, h); ctx.font = `${fontSize}px Arial`;
                    ctx.fillStyle = '#fff'; ctx.fillText(asset.emoji || '?', x + w/2, drawY + h/2);
                }
            } else {
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const fontSize = Math.min(w, h) * 0.8; ctx.font = `${fontSize}px Arial`;
                ctx.fillStyle = '#fff'; ctx.fillText(asset.emoji || '?', x + w/2, drawY + h/2);
            }
            ctx.restore();
        };

        const drawRoundRect = (ctx, x, y, w, h, r) => {
            if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
            if (r < 0) r = 0;
            ctx.beginPath(); ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        };

        const Controls = ({ onInput }) => {
            const handleAction = (key, active) => (e) => {
                if(e.cancelable && e.type !== 'mousedown') e.preventDefault(); 
                e.stopPropagation();
                onInput(key, active);
            };

            return (
                <div className="absolute inset-0 pointer-events-none z-50">
                    <div className="absolute bottom-4 left-4 pointer-events-auto">
                        <div className="flex flex-col items-center gap-1">
                             <div className="flex gap-3">
                                <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                     onTouchStart={handleAction('ArrowLeft', true)} onTouchEnd={handleAction('ArrowLeft', false)}
                                     onMouseDown={handleAction('ArrowLeft', true)} onMouseUp={handleAction('ArrowLeft', false)}>‚¨Ö</div>
                                <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                     onTouchStart={handleAction('ArrowRight', true)} onTouchEnd={handleAction('ArrowRight', false)}
                                     onMouseDown={handleAction('ArrowRight', true)} onMouseUp={handleAction('ArrowRight', false)}>‚û°</div>
                             </div>
                             <div className="touch-btn w-16 h-16 md:w-20 md:h-20"
                                  onTouchStart={handleAction('ArrowDown', true)} onTouchEnd={handleAction('ArrowDown', false)}
                                  onMouseDown={handleAction('ArrowDown', true)} onMouseUp={handleAction('ArrowDown', false)}>‚¨á</div>
                        </div>
                    </div>

                    <div className="absolute bottom-6 right-6 pointer-events-auto flex gap-3 items-end">
                        <div className="touch-btn shoot-btn w-20 h-20 md:w-24 md:h-24 mb-1"
                             onTouchStart={handleAction('Space', true)} onTouchEnd={handleAction('Space', false)}
                             onMouseDown={handleAction('Space', true)} onMouseUp={handleAction('Space', false)}>üî´</div>
                        <div className="touch-btn jump-btn w-20 h-20 md:w-24 md:h-24 mb-12"
                             onTouchStart={handleAction('ArrowUp', true)} onTouchEnd={handleAction('ArrowUp', false)}
                             onMouseDown={handleAction('ArrowUp', true)} onMouseUp={handleAction('ArrowUp', false)}>‚¨Ü</div>
                    </div>
                </div>
            );
        };

        const StatusOverlay = ({ hp, bossHp, currentTarget, feedback, total, completed }) => (
            <div className="absolute top-0 left-0 w-full p-2 flex justify-between items-start pointer-events-none game-overlay z-30">
                <div className="flex flex-col gap-1">
                    <div className="bg-black bg-opacity-60 px-2 py-1 rounded border border-green-500 text-green-400 font-bold text-sm md:text-base">‚ù§Ô∏è {hp}%</div>
                    {total && <div className="bg-black bg-opacity-60 px-2 py-1 rounded border border-blue-500 text-blue-300 font-bold text-sm md:text-base">üìö {completed} / {total}</div>}
                </div>
                
                <div className="absolute left-1/2 transform -translate-x-1/2 top-2 w-auto flex flex-col items-center">
                    <div className="bg-red-900 bg-opacity-90 px-3 py-1 rounded-lg border-2 border-red-500 text-center shadow-md">
                        <div className="text-gray-400 text-[10px] uppercase tracking-widest font-bold">‰ªªÂãôÁõÆÊ®ô</div>
                        <div className="text-xl md:text-2xl font-bold text-white whitespace-nowrap"><span className="text-yellow-400">{currentTarget || "..."}</span></div>
                    </div>
                    {feedback && (<div className="mt-2 text-3xl md:text-5xl font-black text-yellow-300 animate-bounce-text" style={{textShadow: '2px 2px 0 red'}}>{feedback}</div>)}
                </div>

                {bossHp !== undefined && (
                    <div className="w-24 md:w-36">
                        <div className="text-right text-red-500 font-bold mb-1 text-xs md:text-sm">BOSS</div>
                        <div className="w-full bg-gray-700 h-3 md:h-5 rounded-full border border-gray-500 overflow-hidden">
                            <div className="bg-red-600 h-full transition-all duration-300" style={{width: `${(bossHp / 140) * 100}%`}}></div>
                        </div>
                    </div>
                )}
            </div>
        );

        const Level1Engine = ({ hp, setHp, onComplete, onGameOver, assets }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const [completedCount, setCompletedCount] = useState(0);
            const [totalWords, setTotalWords] = useState(0);
            const [currentTarget, setCurrentTarget] = useState(null);
            const stateRef = useRef({
                hunter: { x: 100, y: 0, width: 80, height: 80, vy: 0, speed: 5, isGrounded: false, hitFlash: 0, facing: 'right' },
                gravity: 0.6, jumpPower: -13, cameraX: 0, shake: 0, 
                bullets: [], particles: [], enemies: [], words: [], obstacles: [], keys: {}, lastShot: 0, frameCount: 0, currentHp: hp, nextSpawnX: 400, isCompleted: false, wordQueue: []
            });

            useEffect(() => {
                const level1Words = VOCABULARY.slice(0, 10);
                const shuffled = [...level1Words].sort(() => 0.5 - Math.random());
                stateRef.current.wordQueue = shuffled;
                setTotalWords(shuffled.length);
                setCurrentTarget(shuffled[0]);
                
                const animate = () => {
                    if (loopRef.current) {
                        try { loopRef.current(); } 
                        catch(e) { console.error("Game Loop Error L1:", e); }
                    }
                    requestRef.current = requestAnimationFrame(animate);
                };
                requestRef.current = requestAnimationFrame(animate);
                
                window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
                return () => { 
                    cancelAnimationFrame(requestRef.current); 
                    window.removeEventListener('keydown', handleKeyDown); 
                    window.removeEventListener('keyup', handleKeyUp); 
                };
            }, []);

            useEffect(() => { stateRef.current.currentHp = hp; if(hp <= 0) onGameOver(); }, [hp]);

            const handleWordCompleted = () => {
                const nextQueue = stateRef.current.wordQueue.slice(1);
                stateRef.current.wordQueue = nextQueue;
                const nextWord = nextQueue.length > 0 ? nextQueue[0] : null;
                setCurrentTarget(nextWord);
                setCompletedCount(c => c + 1);
                if (!nextWord) { stateRef.current.isCompleted = true; setTimeout(() => onComplete(stateRef.current.currentHp), 1000); }
            };

            const handleKeyDown = (e) => stateRef.current.keys[e.code] = true;
            const handleKeyUp = (e) => stateRef.current.keys[e.code] = false;
            const handleMobileInput = (key, active) => stateRef.current.keys[key] = active;
            const handleWordCompletedRef = useRef(handleWordCompleted);
            handleWordCompletedRef.current = handleWordCompleted;

            const loopLogic = () => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const state = stateRef.current;
                if (state.isCompleted) return;
                const width = 800; const height = 400; const GROUND_LEVEL = height - 60;
                
                state.frameCount++;
                if (state.hunter.hitFlash > 0) state.hunter.hitFlash--;
                if (state.shake > 0) { state.shake *= 0.9; if(state.shake < 0.5) state.shake = 0; }
                const rectIntersect = (r1, r2) => !(r2.x > r1.x + (r1.w || r1.width) || r2.x + (r2.w || r2.width) < r1.x || r2.y > r1.y + (r1.h || r1.height) || r2.y + (r2.h || r2.height) < r1.y);
                const checkSolidCollision = (rect) => { for (let o of state.obstacles) { if (o.solid && !o.delete && rectIntersect(rect, o)) return o; } return null; };
                const spawnBlood = (x, y) => { for(let i=0; i<8; i++) { state.particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 2, life: 1.0, color: `rgba(255, ${Math.random()*50}, 0, 1)` }); } };

                state.hunter.vy += state.gravity;
                const isCrouching = state.keys['ArrowDown'] && state.hunter.isGrounded;
                let isMoving = false;
                let dx = 0;
                if (!isCrouching) {
                    if (state.keys['ArrowLeft']) { dx -= state.hunter.speed; isMoving = true; state.hunter.facing = 'left'; }
                    if (state.keys['ArrowRight']) { dx += state.hunter.speed; isMoving = true; state.hunter.facing = 'right'; }
                }
                let proposedX = state.hunter.x; let proposedCameraX = state.cameraX;
                if (dx < 0) { if (proposedX > 0) proposedX += dx; } else if (dx > 0) { if (proposedX < width / 2) proposedX += dx; else proposedCameraX += dx; }
                const hunterRectX = { x: proposedX + proposedCameraX, y: state.hunter.y, w: state.hunter.width, h: state.hunter.height };
                let collisionRect = { ...hunterRectX };
                if (isCrouching) { collisionRect.h = 45; collisionRect.y += 35; } 

                if (!checkSolidCollision(collisionRect)) { state.hunter.x = proposedX; state.cameraX = proposedCameraX; }

                let nextY = state.hunter.y + state.hunter.vy;
                if (nextY + state.hunter.height >= GROUND_LEVEL) { nextY = GROUND_LEVEL - state.hunter.height; state.hunter.vy = 0; state.hunter.isGrounded = true; } else { state.hunter.isGrounded = false; }
                const hunterRectY = { x: state.hunter.x + state.cameraX, y: nextY, w: state.hunter.width, h: state.hunter.height };
                let collisionRectY = { ...hunterRectY };
                if (isCrouching) { collisionRectY.h = 45; collisionRectY.y += 35; }

                const hitY = checkSolidCollision(collisionRectY);
                if (hitY) { if (state.hunter.vy > 0) { nextY = hitY.y - state.hunter.height; state.hunter.isGrounded = true; state.hunter.vy = 0; } else if (state.hunter.vy < 0) { nextY = hitY.y + hitY.h; state.hunter.vy = 0; } }
                state.hunter.y = nextY;

                if (state.keys['ArrowUp'] && state.hunter.isGrounded && !isCrouching) { state.hunter.vy = state.jumpPower; state.hunter.isGrounded = false; }
                if (state.keys['Space'] && Date.now() - state.lastShot > 300) {
                    const shootUp = state.keys['ArrowUp']; const isLeft = state.hunter.facing === 'left';
                    const bulletVx = shootUp ? 0 : (isLeft ? -10 : 10); const bulletVy = shootUp ? -10 : 0;
                    let spawnY = state.hunter.y + (shootUp ? -10 : 40); if (isCrouching) spawnY += 20;
                    const startX = state.hunter.x + state.cameraX + (shootUp ? 40 : (isLeft ? 0 : 80));
                    state.bullets.push({ x: startX, y: spawnY, w: shootUp ? 10 : 20, h: shootUp ? 20 : 10, vx: bulletVx, vy: bulletVy, delete: false });
                    state.lastShot = Date.now();
                }

                if (state.cameraX + width > state.nextSpawnX) {
                    state.nextSpawnX += 300 + Math.random() * 200;
                    const rand = Math.random();
                    if (rand < 0.4) {
                        const type = MONSTER_KEYS[Math.floor(Math.random() * MONSTER_KEYS.length)];
                        const isFlying = type === 'eagle'; const isMonkey = type === 'monkey';
                        let spawnY = GROUND_LEVEL - 80; 
                        if (isFlying) spawnY = Math.random() * (height - 250) + 50; 
                        if (isMonkey) spawnY = -50;
                        state.enemies.push({ x: state.cameraX + width + 50, y: spawnY, w: 80, h: 80, type: type, speed: isFlying ? 3 : 2 + Math.random(), hitPlayer: false, delete: false, isFlying: isFlying, isMonkey: isMonkey });
                    } else if (rand < 0.7) {
                        const obstacleType = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
                        state.obstacles.push({ x: state.cameraX + width + 50, y: GROUND_LEVEL - obstacleType.h + 5, w: obstacleType.w, h: obstacleType.h, type: obstacleType.type, key: obstacleType.key, solid: obstacleType.solid, damage: obstacleType.damage, hitPlayer: false, delete: false });
                    } else {
                        const spawnBaseX = state.cameraX + width + 50;
                        if (currentTarget) state.words.push({ x: spawnBaseX, y: 100 + Math.random() * 200, w: 100, h: 35, text: currentTarget.en, isTarget: true, delete: false });
                        if (currentTarget) state.words.push({ x: spawnBaseX + 180, y: 50 + Math.random() * 300, w: 100, h: 35, text: generateSimilarWord(currentTarget.en), isTarget: false, delete: false });
                        let randomWord = VOCABULARY[Math.floor(Math.random() * 10)];
                        if (currentTarget && randomWord.en === currentTarget.en) randomWord = VOCABULARY[(VOCABULARY.indexOf(randomWord) + 1) % 10];
                        state.words.push({ x: spawnBaseX + 90, y: 150 + Math.random() * 200, w: 100, h: 35, text: randomWord.en, isTarget: false, delete: false });
                    }
                }

                state.bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
                state.enemies.forEach(e => { e.x -= e.speed; if (e.isFlying) { const playerCenterY = state.hunter.y + 40; if (e.y < playerCenterY - 10) e.y += 1; else if (e.y > playerCenterY + 10) e.y -= 1; } if (e.isMonkey) { if (e.y < GROUND_LEVEL - 80) e.y += 4; else e.y = GROUND_LEVEL - 80; } });
                state.words.forEach(w => w.x -= 0.5);
                state.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; }); state.particles = state.particles.filter(p => p.life > 0);
                state.bullets = state.bullets.filter(b => b.x < state.cameraX + width && b.y > -50 && !b.delete); state.enemies = state.enemies.filter(e => e.x > state.cameraX - 100 && !e.delete); state.obstacles = state.obstacles.filter(o => o.x > state.cameraX - 100 && !o.delete); state.words = state.words.filter(w => w.x > state.cameraX - 100 && !w.delete);
                
                const hunterWorldBox = { ...state.hunter, x: state.hunter.x + state.cameraX };
                if (isCrouching) { hunterWorldBox.h = 45; hunterWorldBox.y += 35; }

                let wordMatched = false;
                state.bullets.forEach(b => {
                    if (b.delete) return;
                    let hitSomething = false;
                    state.words.forEach(w => {
                        if (hitSomething) return;
                        if (rectIntersect(b, w)) {
                            hitSomething = true; b.delete = true; w.delete = true; 
                            if (w.isTarget) { wordMatched = true; } 
                            else { state.currentHp -= 10; setHp(state.currentHp); state.hunter.hitFlash = 30; spawnBlood(state.hunter.x + 40, state.hunter.y + 40); }
                        }
                    });
                    state.enemies.forEach(e => { if (!e.delete && rectIntersect(b, e)) { b.delete = true; e.delete = true; } });
                });
                state.enemies.forEach(e => { if (!e.delete && !e.hitPlayer && rectIntersect(hunterWorldBox, e)) { e.hitPlayer = true; state.currentHp -= 15; setHp(state.currentHp); state.hunter.hitFlash = 30; state.shake = 15; spawnBlood(state.hunter.x + 40, state.hunter.y + 40); } });
                state.obstacles.forEach(o => { if (!o.delete && !o.hitPlayer && o.damage && rectIntersect(hunterWorldBox, o)) { o.hitPlayer = true; state.currentHp -= 10; setHp(state.currentHp); state.hunter.vy = -5; state.hunter.hitFlash = 30; state.shake = 10; spawnBlood(state.hunter.x + 40, state.hunter.y + 40); } });
                if (wordMatched) handleWordCompletedRef.current();

                let shakeX = 0, shakeY = 0; if (state.shake > 0) { shakeX = (Math.random() - 0.5) * state.shake; shakeY = (Math.random() - 0.5) * state.shake; }
                ctx.save(); ctx.translate(shakeX, shakeY);
                const gradient = ctx.createLinearGradient(0, 0, 0, height); gradient.addColorStop(0, '#3E4E50'); gradient.addColorStop(1, '#1A2525'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
                // Draw clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                const cloudSpeed = 0.1; const scroll = state.cameraX * cloudSpeed;
                const cloudPositions = [{x:100,y:50,s:60}, {x:300,y:80,s:50}, {x:600,y:40,s:70}, {x:900,y:70,s:55}, {x:1200,y:50,s:65}];
                const loopWidth = 1200; const offset = Math.floor(scroll / loopWidth) * loopWidth;
                for (let i = 0; i < 2; i++) {
                    const layerOffset = offset + i * loopWidth;
                    cloudPositions.forEach(cloud => {
                        const drawX = cloud.x + layerOffset - scroll;
                        if (drawX + cloud.s > 0 && drawX - cloud.s < width) {
                            ctx.beginPath(); ctx.arc(drawX, cloud.y, cloud.s * 0.6, 0, Math.PI * 2); ctx.arc(drawX + cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.arc(drawX - cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.fill();
                        }
                    });
                }

                ctx.fillStyle = '#1b2124'; for(let i=0; i<8; i++) { const treeX = i * 150 + 20; ctx.beginPath(); ctx.moveTo(treeX - state.cameraX * 0.3, height); ctx.lineTo(treeX + 30 - state.cameraX * 0.3, height - 200); ctx.lineTo(treeX + 60 - state.cameraX * 0.3, height); ctx.fill(); }
                ctx.fillStyle = '#1a0505'; ctx.fillRect(0, GROUND_LEVEL, width, height - GROUND_LEVEL);
                ctx.fillStyle = '#2e3b2e'; ctx.fillRect(0, GROUND_LEVEL, width, 15);
                state.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha = 1.0;
                if (state.hunter.hitFlash > 0 && Math.floor(state.hunter.hitFlash / 3) % 2 === 0) { ctx.globalAlpha = 0.6; ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(state.hunter.x + 40, state.hunter.y + 40, 45, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha = 1.0;
                const isAimingUp = state.keys['ArrowUp'];
                drawEntity(ctx, assets, 'hunter', state.hunter.x - 5, state.hunter.y, 80, 80, state.frameCount, isMoving, isAimingUp, isCrouching, state.hunter.facing);
                state.obstacles.forEach(o => { const screenX = o.x - state.cameraX; drawEntity(ctx, assets, o.key || o.type, screenX, o.y, o.w, o.h); });
                state.enemies.forEach(e => { const screenX = e.x - state.cameraX; drawEntity(ctx, assets, e.type, screenX, e.y, e.w, e.h, state.frameCount, true); });
                
                ctx.font = '900 18px "Noto Sans TC"'; 
                state.words.forEach(w => { 
                    const screenX = w.x - state.cameraX; 
                    const textMetrics = ctx.measureText(w.text || '?');
                    w.w = textMetrics.width + 40; 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeStyle = '#444'; ctx.lineWidth = 2; 
                    drawRoundRect(ctx, screenX, w.y, w.w, w.h, 10); ctx.fill(); ctx.stroke(); 
                    ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                    ctx.fillText(w.text || '?', screenX + w.w / 2, w.y + w.h / 2); 
                });
                ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                // Inline bullet effect
                state.bullets.forEach(b => {
                    const screenX = b.x - state.cameraX; const screenY = b.y;
                    ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = '#ff4500'; ctx.fillStyle = '#ff4500'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 7, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                });
                ctx.restore();
            };

            const loopRef = useRef(loopLogic);
            loopRef.current = loopLogic;

            return (
                <div className="w-full h-full relative">
                    <canvas ref={canvasRef} width={800} height={400}/>
                    <StatusOverlay hp={hp} currentTarget={currentTarget?.zh} total={totalWords} completed={completedCount} />
                    <Controls onInput={handleMobileInput} />
                </div>
            );
        };

        const Level2Engine = ({ hp, setHp, onWin, onGameOver, assets }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const [bossHp, setBossHp] = useState(140);
            const [currentQ, setCurrentQ] = useState(null);
            const [feedback, setFeedback] = useState("");
            const [qIndex, setQIndex] = useState(0);

            const LEVEL2_WORDS = useRef(VOCABULARY.slice(10, 17)).current;
            const stateRef = useRef({
                hunter: { x: 50, y: 0, width: 80, height: 80, vy: 0, speed: 5, isGrounded: false, hitFlash: 0, facing: 'right' },
                gravity: 0.6, jumpPower: -13,
                boss: { x: 600, y: 160, w: 300, h: 300, vx: 0, vy: 2, state: 'idle', timer: 0, attackTimer: 0, hitFlash: 0 },
                platforms: [{ x: 100, y: 300, w: 100, h: 20 }, { x: 300, y: 220, w: 100, h: 20 }, { x: 500, y: 150, w: 100, h: 20 }, { x: 200, y: 100, w: 80, h: 20 }],
                bullets: [], particles: [], words: [], bossAttacks: [], obstacles: [], enemies: [], keys: {}, lastShot: 0, wordTimer: 0, frameCount: 0, currentHp: hp, bossHp: 140, shake: 0, cameraX: 0
            });

            useEffect(() => {
                setCurrentQ(LEVEL2_WORDS[0]);
                const animate = () => {
                    if (loopRef.current) {
                        try { loopRef.current(); }
                        catch(e) { console.error("Game Loop Error L2:", e); }
                    }
                    requestRef.current = requestAnimationFrame(animate);
                };
                requestRef.current = requestAnimationFrame(animate);

                window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
                return () => { 
                    cancelAnimationFrame(requestRef.current);
                    window.removeEventListener('keydown', handleKeyDown); 
                    window.removeEventListener('keyup', handleKeyUp); 
                };
            }, []);

            useEffect(() => { stateRef.current.currentHp = hp; if(hp <= 0) onGameOver(); }, [hp]);

            const spawnWords = (targetWord) => {
                const words = [];
                const correct = targetWord || LEVEL2_WORDS[qIndex] || VOCABULARY[0];
                const getRandomPos = () => ({ x: 200 + Math.random() * 500, y: 50 + Math.random() * 250 });
                let pos = getRandomPos();
                words.push({ text: correct.en, x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: true, w: 100, h: 35, life: 180 });
                pos = getRandomPos();
                words.push({ text: generateSimilarWord(correct.en), x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: false, w: 100, h: 35, life: 180 });
                pos = getRandomPos();
                let distractor = LEVEL2_WORDS[Math.floor(Math.random() * LEVEL2_WORDS.length)];
                while(distractor.en === correct.en) { distractor = LEVEL2_WORDS[Math.floor(Math.random() * LEVEL2_WORDS.length)]; }
                words.push({ text: distractor.en, x: pos.x, y: pos.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, isCorrect: false, w: 100, h: 35, life: 180 });
                stateRef.current.words = words;
            };

            const nextQuestion = () => {
                const nextIdx = qIndex + 1;
                if (nextIdx >= LEVEL2_WORDS.length) { onWin(); } else { setQIndex(nextIdx); setCurrentQ(LEVEL2_WORDS[nextIdx]); stateRef.current.words = []; stateRef.current.wordTimer = 180; }
            };

            const handleKeyDown = (e) => stateRef.current.keys[e.code] = true;
            const handleKeyUp = (e) => stateRef.current.keys[e.code] = false;
            const handleMobileInput = (key, active) => stateRef.current.keys[key] = active;

            const spawnBlood = (x, y) => { for(let i=0; i<8; i++) { stateRef.current.particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 2, life: 1.0, color: `rgba(255, ${Math.random()*50}, 0, 1)` }); } };
            const rectIntersect = (r1, r2) => !(r2.x > r1.x + (r1.w || r1.width) || r2.x + (r2.w || r2.width) < r1.x || r2.y > r1.y + (r1.h || r1.height) || r2.y + (r2.h || r2.height) < r1.y);

            const loopLogic = () => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const state = stateRef.current;
                const width = 800; const height = 400; const GROUND_LEVEL = height - 60;

                state.frameCount++;
                if (state.hunter.hitFlash > 0) state.hunter.hitFlash--;
                if (state.boss.hitFlash > 0) state.boss.hitFlash--; 
                if (state.shake > 0) { state.shake *= 0.9; if(state.shake < 0.5) state.shake = 0; }

                state.hunter.vy += state.gravity;
                const isCrouching = state.keys['ArrowDown'] && state.hunter.isGrounded;
                let isMoving = false;
                if (!isCrouching) {
                    if (state.keys['ArrowLeft']) { state.hunter.x -= state.hunter.speed; isMoving = true; state.hunter.facing = 'left'; }
                    if (state.keys['ArrowRight']) { state.hunter.x += state.hunter.speed; isMoving = true; state.hunter.facing = 'right'; }
                }
                if (state.hunter.x < 0) state.hunter.x = 0;
                if (state.hunter.x > width - state.hunter.width) state.hunter.x = width - state.hunter.width;

                let nextY = state.hunter.y + state.hunter.vy;
                let grounded = false;
                if (nextY + state.hunter.height >= GROUND_LEVEL) { nextY = GROUND_LEVEL - state.hunter.height; state.hunter.vy = 0; grounded = true; }
                const playerBottom = state.hunter.y + state.hunter.height;
                state.platforms.forEach(p => { if (state.hunter.vy > 0 && state.hunter.x + state.hunter.width > p.x && state.hunter.x < p.x + p.w && playerBottom <= p.y + 10 && nextY + state.hunter.height >= p.y) { nextY = p.y - state.hunter.height; state.hunter.vy = 0; grounded = true; } });
                state.hunter.y = nextY;
                state.hunter.isGrounded = grounded;

                if (state.keys['ArrowUp'] && state.hunter.isGrounded && !isCrouching) { state.hunter.vy = state.jumpPower; state.hunter.isGrounded = false; }

                if (state.keys['Space'] && Date.now() - state.lastShot > 300) {
                    const shootUp = state.keys['ArrowUp']; const isLeft = state.hunter.facing === 'left';
                    const bulletVx = shootUp ? 0 : (isLeft ? -12 : 12); const bulletVy = shootUp ? -12 : 0;
                    let spawnY = state.hunter.y + (shootUp ? -10 : 40); if (isCrouching) spawnY += 20;
                    const startX = state.hunter.x + state.cameraX + (shootUp ? 40 : (isLeft ? 0 : 80));
                    state.bullets.push({ x: startX, y: spawnY, w: shootUp ? 10 : 20, h: shootUp ? 20 : 10, vx: bulletVx, vy: bulletVy, delete: false });
                    state.lastShot = Date.now();
                }

                if (state.boss.state === 'idle') {
                    state.boss.y = 160 + Math.sin(state.frameCount * 0.05) * 50;
                    state.boss.timer++;
                    if (state.boss.timer > 180) { state.boss.state = Math.random() > 0.5 ? 'advance' : 'fire'; state.boss.timer = 0; }
                } else if (state.boss.state === 'advance') {
                    state.boss.x -= 5;
                    if (state.boss.x < 100) { state.boss.state = 'retreat'; }
                } else if (state.boss.state === 'retreat') {
                    state.boss.x += 3;
                    if (state.boss.x >= 600) { state.boss.state = 'idle'; }
                } else if (state.boss.state === 'fire') {
                    if (state.boss.timer === 0 || state.boss.timer === 20 || state.boss.timer === 40) {
                        const angle = Math.atan2(state.hunter.y - (state.boss.y + 130), state.hunter.x - state.boss.x);
                        state.bossAttacks.push({ x: state.boss.x, y: state.boss.y + 130, vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15, w: 40, h: 15, type: 'blue_beam', angle: angle });
                    }
                    state.boss.timer++;
                    if (state.boss.timer > 60) { state.boss.state = 'idle'; state.boss.timer = 0; }
                }

                state.wordTimer++;
                if (state.wordTimer > 200 && state.words.length === 0 && LEVEL2_WORDS[qIndex]) { spawnWords(LEVEL2_WORDS[qIndex]); state.wordTimer = 0; }

                state.words.forEach(w => { w.x += w.vx; w.y += w.vy; w.life--; if(w.x < 50 || w.x > width - 100) w.vx *= -1; if(w.y < 50 || w.y > height - 100) w.vy *= -1; if (w.life <= 0) w.delete = true; });
                state.words = state.words.filter(w => !w.delete);

                state.bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
                state.bossAttacks.forEach(a => { a.x += a.vx; a.y += a.vy; });
                if(state.particles) { state.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; }); state.particles = state.particles.filter(p => p.life > 0); }

                state.bullets = state.bullets.filter(b => b.x < width && b.y > -50 && !b.delete);
                state.bossAttacks = state.bossAttacks.filter(a => a.x > -50 && !a.delete);

                const hunterBox = { x: state.hunter.x, y: state.hunter.y, w: state.hunter.width, h: state.hunter.height };
                if (isCrouching) { hunterBox.h = 45; hunterBox.y += 35; }
                const bossBox = { x: state.boss.x, y: state.boss.y, w: state.boss.w, h: state.boss.h };

                state.bullets.forEach((b) => {
                    if(b.delete) return;
                    let hitSomething = false;
                    state.words.forEach(w => {
                        if (hitSomething) return;
                        if (rectIntersect(b, w)) {
                            hitSomething = true; b.delete = true; w.delete = true; 
                            if (w.isCorrect) {
                                state.bossHp -= 20; setBossHp(state.bossHp); state.shake = 10; setFeedback("HIT! üí•"); state.boss.hitFlash = 30; 
                                setTimeout(() => { setFeedback(""); nextQuestion(); }, 500);
                            } else { 
                                setFeedback("WRONG! üí¢"); setTimeout(() => setFeedback(""), 500); state.words = []; state.wordTimer = 150; 
                            }
                        }
                    });
                    if (!hitSomething && rectIntersect(b, bossBox)) { b.delete = true; state.particles.push({ x: b.x, y: b.y, vx: -5, vy: (Math.random()-0.5)*10, life: 0.5, color: '#ffff00' }); }
                });

                if (state.hunter.hitFlash <= 0) {
                    if (rectIntersect(hunterBox, bossBox)) { state.currentHp -= 20; setHp(state.currentHp); state.hunter.hitFlash = 40; state.shake = 20; state.hunter.vy = -10; state.hunter.x -= 50; spawnBlood(state.hunter.x, state.hunter.y); }
                    state.bossAttacks.forEach(a => { if (!a.delete && rectIntersect(hunterBox, a)) { a.delete = true; state.currentHp -= 15; setHp(state.currentHp); state.hunter.hitFlash = 30; state.shake = 10; spawnBlood(state.hunter.x, state.hunter.y); } });
                }

                let shakeX = 0, shakeY = 0; if (state.shake > 0) { shakeX = (Math.random() - 0.5) * state.shake; shakeY = (Math.random() - 0.5) * state.shake; }
                ctx.save(); ctx.translate(shakeX, shakeY);
                const gradient = ctx.createLinearGradient(0, 0, 0, height); gradient.addColorStop(0, '#3E4E50'); gradient.addColorStop(1, '#1A2525'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                const cloudSpeed = 0.1; const scroll = 0; 
                const cloudPositions = [{x:100,y:50,s:60}, {x:300,y:80,s:50}, {x:600,y:40,s:70}, {x:900,y:70,s:55}, {x:1200,y:50,s:65}];
                cloudPositions.forEach(cloud => {
                    const drawX = cloud.x;
                    ctx.beginPath(); ctx.arc(drawX, cloud.y, cloud.s * 0.6, 0, Math.PI * 2); ctx.arc(drawX + cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.arc(drawX - cloud.s * 0.5, cloud.y + 10, cloud.s * 0.5, 0, Math.PI * 2); ctx.fill();
                });

                ctx.fillStyle = '#1b2124'; for(let i=0; i<8; i++) { const treeX = i * 150 + 20; ctx.beginPath(); ctx.moveTo(treeX, height); ctx.lineTo(treeX + 30, height - 200 - Math.random()*50); ctx.lineTo(treeX + 60, height); ctx.fill(); }
                ctx.fillStyle = '#1a0505'; ctx.fillRect(0, GROUND_LEVEL, width, height - GROUND_LEVEL);
                ctx.fillStyle = '#2e3b2e'; ctx.fillRect(0, GROUND_LEVEL, width, 15);
                
                ctx.fillStyle = '#5d4037';
                state.platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = '#3e2723'; ctx.strokeRect(p.x, p.y, p.w, p.h); });

                state.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha = 1.0;
                if (state.hunter.hitFlash > 0 && Math.floor(state.hunter.hitFlash / 3) % 2 === 0) { ctx.globalAlpha = 0.6; ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(state.hunter.x + 40, state.hunter.y + 40, 45, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha = 1.0;
                const isAimingUp = state.keys['ArrowUp'];
                drawEntity(ctx, assets, 'hunter', state.hunter.x - 5, state.hunter.y, 80, 80, state.frameCount, isMoving, isAimingUp, isCrouching, state.hunter.facing);
                drawEntity(ctx, assets, 'boss', state.boss.x, state.boss.y, state.boss.w, state.boss.h, state.frameCount, true); 
                
                if (state.boss.hitFlash > 0) { ctx.strokeStyle = `rgba(255, 0, 0, ${state.boss.hitFlash / 30})`; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(state.boss.x + state.boss.w/2, state.boss.y + state.boss.h/2, 100, 0, Math.PI*2); ctx.stroke(); }

                state.bossAttacks.forEach(a => {
                    if (a.type === 'blue_beam') {
                        ctx.save(); ctx.translate(a.x, a.y); ctx.rotate(a.angle || 0); 
                        ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#00ffff'; ctx.fillRect(0, -5, a.w, a.h); 
                        ctx.fillStyle = '#ffffff'; ctx.fillRect(0, -2, a.w, a.h/2); ctx.restore();
                    } else { ctx.font = '30px Arial'; ctx.fillText('üî•', a.x, a.y + 20); }
                });
                
                ctx.font = '900 18px "Noto Sans TC"'; 
                state.words.forEach(w => { 
                    const textMetrics = ctx.measureText(w.text || '?'); w.w = textMetrics.width + 40;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeStyle = '#444'; ctx.lineWidth = 2; 
                    drawRoundRect(ctx, w.x, w.y, w.w, w.h, 10); ctx.fill(); ctx.stroke(); 
                    ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                    ctx.fillText(w.text || '?', w.x + w.w / 2, w.y + w.h / 2); 
                });
                ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                // Inline bullet effect
                state.bullets.forEach(b => {
                    const screenX = b.x - state.cameraX; const screenY = b.y;
                    ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = '#ff4500'; ctx.fillStyle = '#ff4500'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 7, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 5; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(screenX + b.w/2, screenY + b.h/2, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                });
                ctx.restore();
            };

            const loopRef = useRef(loopLogic);
            loopRef.current = loopLogic;

            return (
                <div className="w-full h-full relative">
                    <canvas ref={canvasRef} width={800} height={400}/>
                    <StatusOverlay hp={hp} bossHp={bossHp} currentTarget={currentQ?.zh} feedback={feedback} />
                    <Controls onInput={handleMobileInput} />
                </div>
            );
        };

        function App() {
            const [gameState, setGameState] = useState('menu'); 
            const [score, setScore] = useState(0);
            const [hp, setHp] = useState(100);
            const { images, loaded } = useGameAssets(); // Áç≤ÂèñÂúñÁâáËàáËºâÂÖ•ÁãÄÊÖã

            const startGame = () => { console.log("Start Game Clicked"); setScore(0); setHp(100); setGameState('level1'); };
            const handleLevel1Complete = (finalHp) => { setHp(finalHp); setGameState('transition'); };
            const startLevel2 = () => { setHp(100); setGameState('level2'); };
            const handleGameOver = () => { setGameState('gameover'); };
            const handleWin = () => { setGameState('win'); };

            // Á¢∫‰øùË≥áÊ∫êËºâÂÖ•ÂæåÂÜçÈ°ØÁ§∫ÈÅäÊà≤
            if (!loaded && gameState !== 'menu') {
                return (
                    <div className="flex h-screen w-full items-center justify-center bg-gray-900 text-white">
                        <div className="text-2xl animate-pulse">Ê≠£Âú®ËºâÂÖ•ÈÅäÊà≤Ë≥áÊ∫ê...</div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full relative bg-gray-900 select-none">
                    <div className="landscape-warning fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center text-white p-8 text-center">
                        <div className="text-6xl mb-4">üì±‚û°Ô∏èüì±</div>
                        <h2 className="text-2xl font-bold mb-2">Ë´ãÊóãËΩâÊÇ®ÁöÑË£ùÁΩÆ</h2>
                        <p>ÁÇ∫‰∫ÜÁç≤ÂæóÊúÄ‰Ω≥ÈÅäÊà≤È´îÈ©óÔºåË´ãÂ∞áÊâãÊ©üËΩâÁÇ∫Ê©´Âêë„ÄÇ</p>
                        <button onClick={() => document.querySelector('.landscape-warning').style.display = 'none'} className="mt-4 px-4 py-2 border border-white rounded text-sm opacity-50">Âº∑Âà∂ÈÄ≤ÂÖ• (‰∏çÊé®Ëñ¶)</button>
                    </div>

                    <ErrorBoundary>
                        <div className="game-container">
                            {gameState === 'menu' && <MenuScreen onStart={startGame} />}
                            {gameState === 'level1' && <Level1Engine hp={hp} setHp={setHp} onComplete={handleLevel1Complete} onGameOver={handleGameOver} assets={images} />}
                            {gameState === 'transition' && <TransitionScreen onNext={startLevel2} hp={hp} />}
                            {gameState === 'level2' && <Level2Engine hp={hp} setHp={setHp} onWin={handleWin} onGameOver={handleGameOver} assets={images} />}
                            {gameState === 'win' && <WinScreen onRestart={() => setGameState('menu')} />}
                            {gameState === 'gameover' && <GameOverScreen onRestart={() => setGameState('menu')} score={score} />}
                        </div>
                    </ErrorBoundary>
                </div>
            );
        }

        const MenuScreen = ({ onStart }) => {
            const handleTouchEnd = (e) => {
                e.preventDefault();
                onStart();
            };
            return (
                <div className="absolute inset-0 flex flex-col items-center bg-gray-800 bg-opacity-95 z-40 w-full h-full p-6">
                    <div className="flex-1 flex flex-col items-center justify-center w-full pt-32 pb-10">
                        <h1 className="text-5xl md:text-7xl font-bold mb-10 text-yellow-400 text-center tracking-wider" style={{textShadow: '6px 6px 0 #000'}}>ÂñÆÂ≠óÁçµ‰∫∫ÂÜíÈö™</h1>
                        
                        <button 
                            onClick={onStart} 
                            onTouchEnd={handleTouchEnd}
                            className="px-14 py-6 bg-red-600 hover:bg-red-500 text-white font-bold rounded-2xl text-3xl shadow-2xl transform transition active:scale-95 border-b-8 border-red-800 touch-manipulation">
                            ÈñãÂßãÈÅäÊà≤ (Start)
                        </button>
                    </div>

                    <div className="w-full max-w-2xl bg-black bg-opacity-60 rounded-xl border border-gray-600 p-3 mb-2 opacity-80 backdrop-blur-sm">
                        <div className="flex flex-row justify-between items-center text-xs md:text-sm text-gray-300">
                            <div className="flex-1 text-center border-r border-gray-600 px-2">
                                <span className="text-yellow-300 font-bold block mb-1">üå≤ Á¨¨‰∏ÄÈóú</span>
                                <span>Â∞ÑÊìäÊ≠£Á¢∫ÂñÆÂ≠ó</span>
                            </div>
                            <div className="flex-1 text-center border-r border-gray-600 px-2">
                                <span className="text-red-300 font-bold block mb-1">ü¶ñ Á¨¨‰∫åÈóú</span>
                                <span>Ë∫≤ÈÅøÊÅêÈæçÊîªÊìä</span>
                            </div>
                            <div className="flex-1 text-center px-2">
                                <span className="text-blue-300 font-bold block mb-1">üéÆ Êìç‰Ωú</span>
                                <span>Â∑¶ÊâãÁßªÂãï / Âè≥ÊâãË∑≥Ë∫çÂ∞ÑÊìä</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const TransitionScreen = ({ onNext, hp }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-800 z-40 w-full h-full">
                <h2 className="text-3xl md:text-5xl text-yellow-400 font-bold mb-6">Á¨¨‰∏ÄÈóúÂÆåÊàêÔºÅ</h2>
                <div className="text-7xl mb-8">ü§† üéâ</div>
                <p className="text-2xl mb-10 text-white">ÁõÆÂâçË°ÄÈáè: <span className="text-green-400">{hp}%</span> (Âç≥Â∞áË£úÊªø)</p>
                <button onClick={onNext} onTouchEnd={(e) => { e.preventDefault(); onNext(); }} className="px-10 py-4 bg-blue-600 hover:bg-blue-500 rounded-xl text-2xl font-bold border-b-8 border-blue-800 text-white">ÈÄ≤ÂÖ•Á¨¨‰∫åÈóú (BOSSÊà∞)</button>
            </div>
        );

        const WinScreen = ({ onRestart }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-yellow-900 z-40 w-full h-full">
                <h2 className="text-5xl md:text-6xl text-yellow-300 font-bold mb-6">‰ªªÂãôÂÆåÊàêÔºÅ</h2>
                <p className="text-2xl md:text-3xl mb-10 text-center px-4 text-white">‰Ω†ÊàêÂäüÊìäÊïó‰∫ÜÊÅêÈæçÔºÅ</p>
                <button onClick={onRestart} onTouchEnd={(e) => { e.preventDefault(); onRestart(); }} className="px-10 py-4 bg-green-600 hover:bg-green-500 rounded-xl text-2xl font-bold border-b-8 border-green-800 text-white">ÂõûÂà∞‰∏ªÈÅ∏ÂñÆ</button>
            </div>
        );

        const GameOverScreen = ({ onRestart }) => (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-red-900 z-40 w-full h-full">
                <h2 className="text-6xl md:text-7xl text-gray-200 font-bold mb-8">GAME OVER</h2>
                <button onClick={onRestart} onTouchEnd={(e) => { e.preventDefault(); onRestart(); }} className="px-10 py-4 bg-gray-600 hover:bg-gray-500 rounded-xl text-2xl font-bold border-b-8 border-gray-800 text-white">ÈáçÊñ∞ÊåëÊà∞</button>
            </div>
        );

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>